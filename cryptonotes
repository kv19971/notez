Lecture 3 
excuse me what the fuck 

lecture 4 
AES
block vs stream ciphers discussed - they are one key ciphers 
block cipher - only depends on message and key - same message and key -> same output 
classification criteria for ciphers - what you use to encrypt 

shannons idea of diffusion 
	encryption method should provide good diffusion based on key and message - if you change one bit in message then many bits change in output - if you change one bit in key, at least half change in output 
	good confusion - every output bit is a function of multiple message and key bits
	linear functions - provide diffusion 
	nonlinear functions - provide confusion 
	both together provide both 
Before - DES
	block cipher - 56 bit key - this can be easily broken using exhaustive search today 
AES design 
	- one key (symmetric) cipher 
	- 128bit block size (message blocks) 
	- should have freedom to choose keys with different sizes (128,192,256 bits) - suitable for all applications 
	- better than triple-DES 
	- active life of 30 years 
	- efficient software/hardware implementations 
	- simple design - 
	- suitable for smart cards - 
Design techniques 
	- uses idea of diffusion and confusion 
	- has the following layers
		Linear mixing layer - diffusion 
		Non linear layer - confusion 
		Key addition layer 
REMEMBER - message block ALWAYS 128 bits in this case, regardless of key size
discussing scheme with 128bit key now 
wtf
AES Round function 
	state layer - output of 1 byte for input of one byte - this function has the highest nonlinearity - used for all 16 bytes 
	shiftrows layer - rearranges inputs (state layers output) - for the first bytes in all words, stay - for the second byte in all words, shift to 3 blocks (bytes) left - movement is modulo btw - so if underflow then you go to the end. for 3rd byte shift to left by 2 positions. for last byte shift to left by 1 position 
	2nd state layer - not really a funciton, just an output, diagram sucks and so does the professor lmaoooooooo 
	MixColumns layer - input can be considered a degree 4 polynomial - each input (confusion) is from the state layer - that polynomial * some other poly % some other other poly - you get another 4 bytes - this adds diffusion - REMEMBER YOU ARE WORKING WITH COEFFICIENTS IN INPUTS AND OUTPUTS 
	expand layer - 


-- missed one lecture 

key management for one key ciphers 

generating a key for one key cipher 
	secret key k is concatenation of multiple kis where kis are independent of each other - cant predict next bit based on previous - each is flip of fair coin 
		easy to make short random numbers - but if n is not long, its easy to break,		
		pseudorandom number generator - random numbers are numbers which have no dependency upon each other - but if there are some dependencies, it is pseudorandom 
			machines have finite memory - any sequence of digits produced aren't long enough to be completely random 
			how can you prove number is pseudorandom? - because memory of machines is limited - 
			using this in the real world 
	key set - set of Matrix of 256x256, invertible 
		every single key is a binary matrix 
		enc(X) = KX where X is vector of 256 length 
		can be generated by flip of coin, but then it may not be invertible! 
			generate random square matrix that is invertible?

Secret key generation 
	key size 128 bits and expanding 
	equivalent keys - can decrypt each others messages - as they define the same encryption function - tough to identify
	weak keys 

key distribution 
	- one guy creates the key and shares it securely with the other dude 
	ideas and approaches 
		- physical delivery by A or B or third party 
		- encrypt new key using old shared key 
		- send using encrypted connections to third party 
		- public key ciphers 
		- and many more
key agreement 
	- both parties generate k, do bitwise XOR for both, result is secret key 

key distribution protocol where trusted 3rd party is used (3rd party  == KDC)
	KDC and both A and B use master key - long term superkeys used for protecting session keys
	how are master keys shared? 
	graph 
		|| == concatenation symbol  
		N1 == Nonce - specified how to generate in protocol 
		after initiator sends request || N1 to KDC, you get back an encrypted response. 
		k = session key to be shared between A and B 
		KDC generates encrypted response concatenating k, request, nonce sent before, and encrypted session key for Bob - KDC then sends this to A 
			this is to make sure response came from the KDC - only the KDC and A know ka - master key for A 
			request and N1 is there as timestamp - present for anti replaying purpose - adversary may replay this message and send it back to A, making A think that adversary is KDC 
			length of k, request, N1 fixed 
		ka = master key for A 
		kb = master key for B 
		ID(A|B) = Id of A or B 
		then A forwards Ekb(k || IDA) to bob
			avoiding replay attack - B replies with Ek(N2||IDB) - A is the only person who knows k -if message did come from A, A should be able to extract Nonce N2 and send it (encrypted)
		IDA and IDB need to be concatenated for identification purposes 
		modifications to this protocol 
			omit IDA and IDB concatenation 
			KDC can directly send k to B 

Diffie hellman 
	Discrete logarithms - refresher needed 
		primitive root theorem 
		a = alpha^i % p 
			difficult to find i given a, alpha and p 
			also difficult to factorize - factorize integer into 2 primes 
	rule of thumb for finding primitive roots 
		most common roots are 2,3,5,7 
	key exchange protocol
		breaks if adversary can compute XA or XB 
		but youd have to solve the discrete log problem to crack XA or XB - passive attack
		assume enemy can incept messages - active attacks 
			enemy can change YA and YB during transmission  
			the protocol is not secure against active attacks 
	can we do better?

public key cryptography 

disadvantages of one key cryptography 
	key management - if everyone has to communicate with everyone, need to generate n^2 order of superkeys - where do i store these keys where they'll be secure 
		also have to update these keys frequently 

two key ciphers 
	has 2 key spaces - encryption key space and decryption key space
	needs to satisfy the conditions 
		given encryption key, Eke, Ekd, it is infeasible to compute the decryption key kd 
			in theory, it is possible, given enough time (e.g. 10 years) and compute (by using the most powerful computer in the world)
			infeasible = in computation sense 
		given ciphertext, it is infeasible to derive the plaintext m 	
	special usage 
		people tell you encryption key
		you can use that encryption key to encrypt a message and send 
		people can decrypt ciphertext using their decryption key 
	but there are 2 key ciphers where these conditions are not satisfied 
		remember - matrix multiplication is mod 2 multiplication (result = old result % 2)
		remember - if matrix A is invertible, there exists a matrix B such that AB = Identity matrix 
		let message space, cipher space = {0, 1}*
		encryption key space = decryption key space = set of all invertible 512x512 matrices over F2 = {0,1} with each matrix not being an inverse of itself 
			in this case, the 2 key spaces are the same
		encryption function - done block by block (of 512 bits in this case)
			Ek(x) = kx , where x is message block (vector of length 512x1)
		decryption function  - also done block by block
			Dk(y) = k-1 y - 
		REMEMBER - all artihmetic operations are modulo 2 
		why arent the 2 conditions satisfied? 
			easy to compute the inverse of a matrix (gaussian elimination method) - violates condition 1 
			because condition 1 doesnt hold, condition 2 also doesnt hold 
	therefore, not all 2 key ciphers can be called public key ciphers 
	performance issue in public key ciphers - not good in software and hardware 
		hard to satisfy 2 conditions and be efficient - they allow for computational infeasibility 
	a public key cipher can be used for key distribution 
		encrypt session key using A's public key and send to A 
	a public key cipher can be used for signing documents
		signature - sequence of characters in digital form 
		how to produce signature of digital documents 
			will be discussed later 
			signature generation should be efficient 
		chance of forgery should be small 
		in this case, your encryption key should be private, decryption key should be public 
			ususally its the other way around in different systems 
		also have to have a hash function
			has 1-1 mapping from input space (A*) to fixed size space (B128)
		to send message - you concatenate it with the signature 
			signature = hash of message encrypted using private key (has fixed length cause its hash) 
			verification: make hash of message, decrypt encrypted hash using public decryption key, compare hashes 
			
		why is encryption using private key denoted as Dkd? 
			it is the decryption function - its just a function


EULER theorem discussed 
FERMAT theorem discussed 

RSA cryptosystem discusssed 
 
protocol 
	p, q primes select
	n = p*q
	phi(n) = (p-1)(q-1) - if p and q large, phi(n) is also large 
	decryption key d 1 < d < phi(n) => d= phi(phi(n)) = phi((p-1)(q-1)) - large space 
	e = multiplicative inverse of d modulo phi (n)
	public key = e, n 
	usually d and e wont be the same 
	
	since n not power of 2, do log(2)n = k, plaintext is broken into blocks of length k 
	For each block (with k bits) - C = M^e mod n 
	then M = C^d mod n 
	proving correctness 
		M < n (cause its a binary string turned integer withing 0 .. 2^k-1)
		case 1 - gcd (M, n) = 1
			M^ed mod n // from M = C^d mod n 
			M^u*phi(n) + 1 mod n // since e, d multiplicative inverses of each other mod n
			M^u*phi(n)mod n * M mod n 
			((M^phi(n)mod n) ^ u) * M mod n 
			M mod n // using euler's theorem  
			M 
		case 2 - gcd (M, n) = q
			we have M = tp 0 < t < q (t cannot be 0, then M 0) (t cannot be q, as then gcd(M, n) would be q) gcd(M, q) = 1
			ed = u * phi(n) + 1
			(M^u*phi(n) - 1) mod q = M^(u*(p-1)*(q-1)) - 1 mod q = 0
	
			M^ed - M mod N =
			M(M^ed-1 - 1) mod n = tp(M^u*phi(n) - 1) mod pq = 0
		case 3 - gcd (M, n) = p
		case 4 - gcd (M, n) = pq
			Happens only when M = 0
			as M always less than M <= 2^k - 1
			and if M = 0, then C = 0

conditions C1 and C2 satisfied? 
	parameters
		p, q - huge prime numbers 
			n = p*q
			phi(n) = p-1 * q-1
			e
			d
		private key = d
		keep p,q phi secret
			p, q -> phi 
			phi -> secret key 
	cracking RSA 
		given n, factorize into 2 primes p, q - very hard problem 
			good benchmark
			prime factorization algos - non polynomial time 
		compute phi(n) directly, but this is harder than factorization, as n is large - harder
		compute d directly - even harder
	so no one has proved if C1 and C2 has been satisfied, but people believe that it is 

	do we have a cipher that satisfies the 2 conditions - we dont know 
	
choosing p and q
	shouldnt be of special form e.g. 2^k - 1, if they are theres a very efficient factorization algo that can crack, these primes should be random 
	p, q cannot be close to each other (p-q small), else system not secure 
		cannot be too far either 
		just differ by a few digits 



missed lecture on elgamal public key crypto system 
--


signature
	can u invalidate a signed contract? 
		get rid of the key used to sign - can get rid of finger for fingerprint sign 
		it doesnt always work - HK has database with user details incl. fingerprints - so if you destroy fingerprint it doesnt matter as its in the database 
	
	we need an organization that can prove that you own your biometrics 

digital certificate 
	managed by trusted authority 
	can authenticate identity of holder 
	cannot be duplicated 
	cannot be forged 

	types 
		server certificates 
		personal certificates - client certificates 

	certificates for machines - to authenticate in M2M communications 
	
	standard for certificates? Not really, you have certain attributes that have to be there sometimes - e.g. name, picture, address, validity etc 

	authority needs to sign certificate - e.g. HK immigration needs to sign your passport - get parameters - hash - sign - and then store 
		verification - decrypt signed content to verify, then do the same with the parent
		extension - lists uses of digital certificate
	detecting modifications - checksum then encrypt 

Public key infrastructure 
	LDAP server - directory having everyone's name and public key and digital certificates

CA CHAINS 
	local CA - issues to users 
	Intermediate CAs = issues to local CAs 
	Root CA = issues to intermediate CAs and itself - as it needs to have a certificate of its own 

Trust 
	propagates - u verify signature of local CA on your certificate, then you verify local CAs certificate, then u verify intermediate CAs certificate 

SHA1 functions 
	limit on input - 2^64 bits - never have this much data in reality 

design consideration 
	have good confusion - non linear functions 
	good diffusion - linear functions 
	linear and nonlinearity - relative concept 
		e.g. s(x) = x^10 non linear with +, but linear with x or *
			s(x1x2) = s(x1)*s(x2)
	have collision resistance property 
	have one way property 
	be fast 
		use all of processing power 

Implementation 
	padding - HAS to be there - LSB 1 rest 0s - if message length 448 then add 448 padding bits 
	padding + message = 448 bits 
		final length multiple of 512 
	bin rep of length m - 64 bits 
		total = 512 bits 
	reserve only 64 bits to represent length - which is why length limited 
	
	got constants 
		floored of 2^30 * sqrt(2) ... 
		derived from intuition and trial and error 
	
	in step 4 
		for each 512 bit block 
			repeat processing 
		constants - initial values 
		in theory we need 80 constants? but most are the same - for efficiency purposes
		operation to compute wi for i > 16 - cyclic = you go back after 80 to 16 - it s a linear recurrent formula 
	function Ft	
		S operation - shift 
		changing position of A...E - diffusion 
		S operations - linear 
		+ - linear 
		ft - nonlinear 
			using logic operations here - extremely fast 
			layering adds complexity 
			mixing different binary operations - confusion 
		what is the purpose of having 80 steps 
			function composition adds to complexity 
			more rounds - worse performance - but higher security  
		initial vals 
	collisions 
		m1 that results in same hash as m may not have any meaning 
 -- Missed some lecture IDK 

key exchange protocols 
	diffie hellman not secure wrt active attacks
	active attack - enemy can stop, replay, modify and forward messages to A, B 
	passive attack - enemy can only intercept messages 
	merkel protocol 
		assumption - we dont know each others public key 
		A sends pk || ID to B
		B sends back k encrypted using pk send by A 
		NOT SECURE with active attack - no shit dumbass 
			middle man can impersonate easily A or B - neither parties are able to authenticate each other
			Diffie hellman - has the same problem  
			both parties dont know each others public keys before hand 
		how can we change to make it ineffective to active attack 
			allow some sort of authentication 
	needham schroder 
		assume both parties have shared Pub key 
		Nonce N1 and N2 
		A sends IDA || N1 encrypted with B's public key 
		Then B sends encrypted N1 || N2 (where N2 is some random nonce)
			B sends a challenge to A, if A is indeed A then A should be able to recover N2
			Only A can solve challenge as N1 || N2 is encrypted with A's pubkey 
		then A sends N2 back with key encrypted 
		encrypted data sent using each party's public key 
		proof - is there any other way to attack this protocol, assuming public key cipher is secure 
			there is a design flaw - what is it? - not required 
		
	a protocol problem 
		the shipping problem 	
		may not have to use both locks 
		regular pub key encryption like problem wont work - assuming that someone can lock the lock in the middle, rendering the lock useless - so u cant send just the unlocked lock  
		solution 
			box = doubly locked box 
			Alice Locks box with photos with own lock - sends to bob
				No one can tamper with lock (as its already locked), and the photos - during travel  
			Bob gets locked box - alice has the key - take received box and lock box with own lock - shipped to alice 
			Alice then removes own lock - once she sees bob's lock she knows its bob who got the box and locked it - she then sends it back to bob 
			Bob then removes his own lock - and open the box 
			MITM attack - doesnt work - as we assume that all parties can identify each others locks - if u remove this assumption then MITM attack works 
		A digital version of the mechanical solution 
			exchange photos using email - 
			AES? No - still need to exchange shared secret key 
			this brings us to three pass protocol 
	Shamir three pass protocol 
		photos - binary string 
		2parties - A and B
		parameters
			huge prime number p 20-30 digits - discrete log problem mod p is very hard - p is public knowledge 
			A selects random number a s.t. gcd (a, p-1) = 1 - concerned with a^-1 (inverse of a mod p-1) 
			B selects b s.t. gcd(b, p-1) = 1 - concerned with b^-1
		Algo 
			assumed data to be shared - k 
			A sends k1 = k^a mod p (a is like A's lock on box - locked ONLY by a)
			B sends k2 = k1 ^ b mod p (bob does double locking - uses his own digital lock)
			A sends k3 = k2^(a^-1) mod p (A removes its lock, sends box locked with B's lock back to B)
			k3 = k2^(a^-1) mod p 
			  = (k1^b mod p)^(a^-1) mod p 
			  = ((k^a mod p)^b mod p)^(a^-1) mod p 
			  = k^b mod p (a and a^-1 cancel out - represents unlocking mechanism)
			to unlock, B uses b^-1 to get k from k3 
			if p is small, then recovered k may be something else (so rmb that k << b needs to be true)
			Here, we dont need the assumption that A and B need to know each other's public key (i.e. know what each others' locks look like)
			passive attacks 
				depends on difficulty of solving the discrete log problem - which isnt possible 
				need to solve to recover b from k2 and k1 
			active attacks 
				depends on whether they can recognize each other's primary keys - which is not true in this case 
			also we can just use the merkle protocol in place of this, as that too doesnt offer MITM protection 
			
			
